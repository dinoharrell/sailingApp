<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Speed Monitor v4.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { background-color: #0d1117; color: #ffffff; }
        .speed-display { font-size: 5rem; line-height: 1; }
        .unit { font-size: 1.5rem; opacity: 0.7; margin-top: -10px; }
        .data-box { @apply text-center bg-gray-800 p-6 rounded-lg shadow-2xl w-full; margin-bottom: 1.5rem;}
        .chart-box { 
            @apply bg-gray-800 p-4 rounded-lg shadow-2xl w-full; 
            max-height: 350px; 
            position: relative; 
        }
        .log-box {
            @apply bg-gray-900 p-2 border border-gray-700 rounded-lg text-xs font-mono;
            height: 60vh; /* Increased height as requested for maximal visibility */
            overflow-y: scroll; 
            color: #a0a0a0; 
        }
        .bg-yellow-600 { background-color: #d97706; }
        .bg-green-700 { background-color: #047857; }
        .bg-red-900 { background-color: #7f1d1d; } /* Darker red for explicit errors */
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-center min-h-screen">

    <h1 class="text-xl font-bold mb-6 text-gray-400">SAILING SPEED MONITOR v4.2 (GPS SOG)</h1>

    <div class="w-full max-w-lg space-y-4">
        <div class="data-box"><p class="text-2xl mb-2 text-blue-400">AVG (LAST 10 SEC)</p><p id="avg-speed-10" class="speed-display font-mono text-green-400">--.-</p><p class="unit">KNOTS</p></div>
        <div class="data-box"><p class="text-2xl mb-2 text-blue-400">AVG (LAST 30 SEC)</p><p id="avg-speed-30" class="speed-display font-mono text-yellow-400">--.-</p><p class="unit">KNOTS</p></div>
        <div class="chart-box"><p class="text-xl mb-2 text-blue-400 text-left">RAW SPEED (LAST 60 SEC)</p><canvas id="speedChart"></canvas></div>
    </div>
    <div class="mt-8 p-3 w-full max-w-lg rounded bg-red-800 text-white" id="status-box">
        <p id="status-message" class="text-sm">Initializing GPS...</p>
    </div>
    
    <div class="mt-2 w-full max-w-lg log-box" id="log-history">
        </div>

    <script>
        // --- 1. CONFIGURATION ---
        const AVERAGE_WINDOW_10_SEC = 10;
        const AVERAGE_WINDOW_30_SEC = 30;
        const GRAPH_WINDOW_SEC = 60;
        // const MAX_SAILING_SPEED_KNOTS = 7.0; // REMOVED as requested (replaced by more robust filters)
        const MAX_ACCELERATION_KNOTS_PER_SEC = 1.0;
        const MIN_SPEED_KNOTS = 0.05;
        const MAX_HORIZONTAL_ACCURACY_METERS = 10.0;
        const MAX_LOG_ENTRIES = 30; // Maximum number of entries to retain in the log box
        
        const KNOTS_PER_METER_PER_SECOND = 1.94384;
        const DATA_KEY = 'sailingSpeedData';

        // --- 2. DATA STRUCTURE & GLOBALS ---
        let speedBuffer = [];
        let watchId; 
        let speedChart;
        let lastPosition = null; 

        // --- 3. UTILITY FUNCTIONS ---
        function calculateTimeDelta(current) {
            if (lastPosition) {
                const timeSeconds = (current.timestamp - lastPosition.timestamp) / 1000;
                return timeSeconds > 0 ? timeSeconds : 0;
            }
            return 0;
        }

        // --- 4. PERSISTENCE, CORE LOGIC, CHART UTILS ---
        function loadData() {
            try {
                const storedData = localStorage.getItem(DATA_KEY);
                if (storedData) {
                    const loadedBuffer = JSON.parse(storedData);
                    const now = Date.now();
                    const timeCutoff = now - (GRAPH_WINDOW_SEC * 1000);
                    speedBuffer = loadedBuffer.filter(reading => reading.timestamp >= timeCutoff);
                    if(speedBuffer.length > 0) {
                        lastPosition = {
                            coords: {
                                latitude: speedBuffer[speedBuffer.length - 1].lat,
                                longitude: speedBuffer[speedBuffer.length - 1].lon
                            },
                            timestamp: speedBuffer[speedBuffer.length - 1].timestamp
                        };
                    }
                    // Pass a dummy object, as we only care about time_sec > 0 for acceleration check
                    handlePosition({ coords: { speed: 0, accuracy: 0, latitude: 0, longitude: 0 }, timestamp: now }, true); 
                    showStatus("Data loaded successfully.", false, true); // Simplified startup message
                } else {
                    speedBuffer = []; 
                }
            } catch (e) {
                console.error("Error loading data from Local Storage:", e);
                speedBuffer = [];
                showStatus("Error loading saved data. Starting fresh.", true);
            }
        }
        function saveData() {
            try {
                const dataToStore = JSON.stringify(speedBuffer);
                localStorage.setItem(DATA_KEY, dataToStore);
            } catch (e) {
                console.error("Error saving data to Local Storage:", e);
            }
        }
        function calculateRollingAverage(windowSeconds) {
            const now = Date.now();
            const timeCutoff = now - (windowSeconds * 1000);

            if (windowSeconds === GRAPH_WINDOW_SEC) {
                speedBuffer = speedBuffer.filter(reading => reading.timestamp >= timeCutoff);
            }
            
            const relevantReadings = speedBuffer.filter(reading => reading.timestamp >= timeCutoff);

            if (relevantReadings.length === 0) { return 0.0; }

            const totalSpeed = relevantReadings.reduce((sum, reading) => sum + reading.speed, 0);
            return totalSpeed / relevantReadings.length;
        }

        function mpsToKnots(mps) { return mps * KNOTS_PER_METER_PER_SECOND; }
        
        function updateDisplay(elementId, speed) {
            const displayValue = speed.toFixed(1);
            document.getElementById(elementId).textContent = displayValue;
        }
        
        function showStatus(message, isError = false, isAccepted = false) {
            const statusBox = document.getElementById('status-box');
            const statusMessage = document.getElementById('status-message');
            const logHistory = document.getElementById('log-history');
            
            // 1. UPDATE MAIN STATUS BAR 
            statusMessage.textContent = message;
            
            statusBox.classList.remove('hidden', 'bg-red-900', 'bg-yellow-600', 'bg-green-700');
            
            let prefix = isError ? 'ERR:' : (isAccepted ? 'OK:' : 'NO:'); // New prefixes
            let logClass = ''; 
            
            if (isError) {
                statusBox.classList.add('bg-red-900');
                logClass = 'text-red-400';
            } else if (isAccepted) {
                statusBox.classList.add('bg-green-700');
                logClass = 'text-green-400';
            } else {
                statusBox.classList.add('bg-yellow-600');
                logClass = 'text-yellow-400';
            }

            // 2. CREATE LOG ENTRY (Persistent History)
            // Shortened timestamp to only show seconds
            const timestamp = new Date().toLocaleTimeString('en-US', { second: '2-digit' }); 
            
            const newLogEntry = document.createElement('div');
            // Log entry uses the prefix and shortened timestamp
            newLogEntry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> <span class="${logClass} font-bold">${prefix}</span> <span class="${logClass}">${message}</span>`;
            
            // Append the new entry to the top of the log (newest at the top)
            if (logHistory.firstChild) {
                logHistory.insertBefore(newLogEntry, logHistory.firstChild);
            } else {
                logHistory.appendChild(newLogEntry);
            }

            // 3. LOG MANAGEMENT (Trim the log)
            while (logHistory.children.length > MAX_LOG_ENTRIES) {
                logHistory.removeChild(logHistory.lastChild);
            }

            // Scroll to the top to see the newest message
            logHistory.scrollTop = 0;
        }

        function initChart() {
            const ctx = document.getElementById('speedChart').getContext('2d');
            const data = speedBuffer.map(reading => ({
                x: reading.timestamp,
                y: reading.speed
            }));

            speedChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Raw Speed (Knots)',
                        data: data,
                        borderColor: '#3b82f6', // blue-500
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        tension: 0.1,
                        pointRadius: 1,
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'second',
                                displayFormats: {
                                    second: 'h:mm:ss a'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                color: '#9ca3af' // gray-400
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Speed (Knots)'
                            },
                            ticks: {
                                color: '#9ca3af'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (!speedChart) return;
            
            const chartData = speedBuffer.map(reading => ({
                x: reading.timestamp,
                y: reading.speed
            }));

            speedChart.data.datasets[0].data = chartData;
            
            const now = Date.now();
            const timeCutoff = now - (GRAPH_WINDOW_SEC * 1000);
            speedChart.options.scales.x.min = timeCutoff;
            speedChart.options.scales.x.max = now;

            speedChart.update('none');
        }


        // --- 5. GEOLOCATION HANDLERS ---

        function handlePosition(position, isLoadedData = false) {
            const currentCoords = position.coords;
            const timestamp = position.timestamp;
            
            // If we are just running this to initialize the display with old data, skip the rest
            if (isLoadedData) {
                const avgSpeed30 = calculateRollingAverage(AVERAGE_WINDOW_30_SEC);
                const avgSpeed10 = calculateRollingAverage(AVERAGE_WINDOW_10_SEC);

                updateDisplay('avg-speed-30', avgSpeed30);
                updateDisplay('avg-speed-10', avgSpeed10);
                updateChart();
                return;
            }

            // 1. CRITICAL FIX: Save the very first fix and exit.
            if (lastPosition === null) {
                lastPosition = position;
                showStatus("Waiting for 2nd fix...", false); // Simplified status
                return; 
            }

            const time_sec = calculateTimeDelta(position);
            
            // --- FILTER 1: ACCURACY CHECK ---
            if (currentCoords.accuracy === null || currentCoords.accuracy > MAX_HORIZONTAL_ACCURACY_METERS) {
                const acc = currentCoords.accuracy === null ? 'N/A' : currentCoords.accuracy.toFixed(1) + 'm';
                // SIMPLIFIED LOG MESSAGE
                showStatus(`Acc. ${acc} > ${MAX_HORIZONTAL_ACCURACY_METERS.toFixed(1)}m max.`, false); 
                return;
            }

            // --- NEW CALCULATION: USE HARDWARE SPEED (SOG) ---
            if (currentCoords.speed === null) {
                // SIMPLIFIED LOG MESSAGE
                showStatus("GPS did not provide SOG.", false); 
                return; 
            }
            
            const speed_mps = currentCoords.speed;
            const speedInKnots = mpsToKnots(speed_mps);
            
            const lastAcceptedSpeed = speedBuffer.length > 0 ? speedBuffer[speedBuffer.length - 1].speed : 0.0;
            
            // --- FILTER 2: ABSOLUTE MAX SPEED CHECK - REMOVED! ---
            // The check for MAX_SAILING_SPEED_KNOTS is removed to allow for a full speed range.
            
            // --- FILTER 3: Acceleration Filter (Max Change Check)
            if (time_sec > 0) {
                const speedChange = Math.abs(speedInKnots - lastAcceptedSpeed);
                const acceleration = speedChange / time_sec;
                
                if (acceleration > MAX_ACCELERATION_KNOTS_PER_SEC) {
                    // SIMPLIFIED LOG MESSAGE
                    showStatus(`Accel. ${acceleration.toFixed(2)} kn/s > ${MAX_ACCELERATION_KNOTS_PER_SEC.toFixed(1)} max.`, false);
                    return; 
                }
            }
            
            // --- FILTER 4: Minimum Speed Check
            if (speedInKnots > MIN_SPEED_KNOTS) { 
                
                // DATA ACCEPTED!
                speedBuffer.push({
                    speed: speedInKnots,
                    timestamp: timestamp,
                    lat: currentCoords.latitude,
                    lon: currentCoords.longitude
                });

                lastPosition = position;
                saveData();
                // SIMPLIFIED LOG MESSAGE
                showStatus(`${speedInKnots.toFixed(1)} kn, ${currentCoords.accuracy.toFixed(1)}m accuracy.`, false, true); 
            } else {
                // DATA REJECTED by MIN_SPEED_KNOTS filter
                lastPosition = position; 
                
                // SIMPLIFIED LOG MESSAGE
                showStatus(`Speed ${speedInKnots.toFixed(2)} kn (stationary).`, false);
            }
            
            // 6. Display Update
            const avgSpeed30 = calculateRollingAverage(AVERAGE_WINDOW_30_SEC);
            const avgSpeed10 = calculateRollingAverage(AVERAGE_WINDOW_10_SEC);

            updateDisplay('avg-speed-30', avgSpeed30);
            updateDisplay('avg-speed-10', avgSpeed10);
            updateChart();
        }

        function handleError(error) {
            let message = '';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    message = "GPS Denied (Code 1).";
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = "Position Unavailable (Code 2).";
                    break;
                case error.TIMEOUT:
                    message = "GPS Timed Out (Code 3).";
                    break;
                default:
                    message = `Unknown GPS error: ${error.message} (Code: ${error.code})`;
            }
            updateDisplay('avg-speed-10', 0);
            updateDisplay('avg-speed-30', 0);
            showStatus(message, true); // Red status bar for errors
        }

        // --- 6. INITIALIZATION ---
        
        function startWatchAfterInitialFix(position) {
            handlePosition(position);

            watchId = navigator.geolocation.watchPosition(
                handlePosition,
                handleError,
                {
                    timeout: 7000, // Watch timeout
                    maximumAge: 0, 
                    enableHighAccuracy: true
                }
            );
        }

        function startGpsWatch() {
            loadData();
            initChart(); 
            
            if (navigator.geolocation) {
                showStatus(speedBuffer.length > 0 ? "GPS Initializing. Historical data displayed." : "Requesting initial GPS fix...", false);
                
                navigator.geolocation.getCurrentPosition(
                    startWatchAfterInitialFix,
                    handleError,
                    {
                        timeout: 15000, // Initial fix timeout
                        maximumAge: 0, 
                        enableHighAccuracy: true
                    }
                );
            } else {
                handleError({ code: -1, message: "Geolocation not supported." });
            }
        }

        document.addEventListener('DOMContentLoaded', startGpsWatch);
        
        window.onbeforeunload = function() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
            }
        };
    </script>
</body>
</html>
