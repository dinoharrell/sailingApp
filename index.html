<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Speed Monitor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { background-color: #0d1117; color: #ffffff; }
        .speed-display { font-size: 5rem; line-height: 1; }
        .unit { font-size: 1.5rem; opacity: 0.7; margin-top: -10px; }
        .data-box { @apply text-center bg-gray-800 p-6 rounded-lg shadow-2xl w-full; margin-bottom: 1.5rem;}
        .chart-box { @apply bg-gray-800 p-4 rounded-lg shadow-2xl w-full; }
        .bg-yellow-600 { background-color: #d97706; }
        .bg-green-700 { background-color: #047857; }
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-center min-h-screen">

    <h1 class="text-xl font-bold mb-6 text-gray-400">SAILING SPEED MONITOR v2.9 (Graph & Time Filter)</h1>

    <div class="w-full max-w-lg space-y-4">
        <div class="data-box"><p class="text-2xl mb-2 text-blue-400">AVG (LAST 10 SEC)</p><p id="avg-speed-10" class="speed-display font-mono text-green-400">--.-</p><p class="unit">KNOTS</p></div>
        <div class="data-box"><p class="text-2xl mb-2 text-blue-400">AVG (LAST 30 SEC)</p><p id="avg-speed-30" class="speed-display font-mono text-yellow-400">--.-</p><p class="unit">KNOTS</p></div>
        <div class="chart-box"><p class="text-xl mb-2 text-blue-400 text-left">RAW SPEED (LAST 60 SEC)</p><canvas id="speedChart"></canvas></div>
    </div>
    <div class="mt-8 p-3 w-full max-w-lg rounded bg-red-800 text-white" id="status-box">
        <p id="status-message" class="text-sm">Initializing GPS...</p>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const AVERAGE_WINDOW_10_SEC = 10;
        const AVERAGE_WINDOW_30_SEC = 30;
        const GRAPH_WINDOW_SEC = 60;
        const MAX_SAILING_SPEED_KNOTS = 7.0;
        const MAX_ACCELERATION_KNOTS_PER_SEC = 1.0;
        const MIN_SPEED_KNOTS = 0.05;
        const MIN_TIME_DELTA_SECONDS = 5.0; // NEW: Minimum time between accepted fixes
        const KNOTS_PER_METER_PER_SECOND = 1.94384;
        const EARTH_RADIUS_METERS = 6371000;
        const DATA_KEY = 'sailingSpeedData';

        // --- 2. DATA STRUCTURE & GLOBALS ---
        let speedBuffer = [];
        let watchId; 
        let speedChart;
        let lastPosition = null;

        // --- 3. GEOMETRY FUNCTIONS (Unchanged) ---
        function toRad(degrees) { return degrees * Math.PI / 180; }

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = EARTH_RADIUS_METERS;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; 
        }

        function calculateSpeed(current) {
            const distanceMeters = getDistance(
                lastPosition.coords.latitude, 
                lastPosition.coords.longitude, 
                current.coords.latitude, 
                current.coords.longitude
            );
            const timeSeconds = (current.timestamp - lastPosition.timestamp) / 1000;

            if (timeSeconds > 0) {
                return { 
                    speed_mps: distanceMeters / timeSeconds,
                    time_sec: timeSeconds
                };
            }
            return { speed_mps: 0, time_sec: 0 };
        }

        // --- 4. PERSISTENCE, CORE LOGIC, CHART UTILS ---
        function loadData() {
            try {
                const storedData = localStorage.getItem(DATA_KEY);
                if (storedData) {
                    const loadedBuffer = JSON.parse(storedData);
                    const now = Date.now();
                    const timeCutoff = now - (GRAPH_WINDOW_SEC * 1000);
                    speedBuffer = loadedBuffer.filter(reading => reading.timestamp >= timeCutoff);
                    if(speedBuffer.length > 0) {
                        lastPosition = {
                            coords: {
                                latitude: speedBuffer[speedBuffer.length - 1].lat,
                                longitude: speedBuffer[speedBuffer.length - 1].lon
                            },
                            timestamp: speedBuffer[speedBuffer.length - 1].timestamp
                        };
                    }
                    handlePosition({ coords: { speed: null }, timestamp: now });
                    showStatus("Data loaded successfully from previous session.", false);
                } else {
                    speedBuffer = []; 
                }
            } catch (e) {
                console.error("Error loading data from Local Storage:", e);
                speedBuffer = [];
                showStatus("Error loading saved data. Starting fresh.", true);
            }
        }
        function saveData() {
            try {
                const dataToStore = JSON.stringify(speedBuffer);
                localStorage.setItem(DATA_KEY, dataToStore);
            } catch (e) {
                console.error("Error saving data to Local Storage:", e);
            }
        }
        function calculateRollingAverage(windowSeconds) {
            const now = Date.now();
            const timeCutoff = now - (windowSeconds * 1000);

            if (windowSeconds === GRAPH_WINDOW_SEC) {
                speedBuffer = speedBuffer.filter(reading => reading.timestamp >= timeCutoff);
            }
            
            const relevantReadings = speedBuffer.filter(reading => reading.timestamp >= timeCutoff);

            if (relevantReadings.length === 0) { return 0.0; }

            const totalSpeed = relevantReadings.reduce((sum, reading) => sum + reading.speed, 0);
            return totalSpeed / relevantReadings.length;
        }

        function mpsToKnots(mps) { return mps * KNOTS_PER_METER_PER_SECOND; }
        
        function updateDisplay(elementId, speed) {
            const displayValue = speed.toFixed(1);
            document.getElementById(elementId).textContent = displayValue;
        }
        
        function showStatus(message, isError = false, isAccepted = false) {
            const statusBox = document.getElementById('status-box');
            const statusMessage = document.getElementById('status-message');
            
            statusMessage.textContent = message;
            
            statusBox.classList.remove('hidden', 'bg-red-900', 'bg-yellow-600', 'bg-green-700');
            
            if (isError) {
                statusBox.classList.add('bg-red-900'); 
            } else if (isAccepted) {
                statusBox.classList.add('bg-green-700'); 
            } else {
                statusBox.classList.add('bg-yellow-600'); 
            }
        }

        function initChart() {
            const ctx = document.getElementById('speedChart').getContext('2d');
            const data = speedBuffer.map(reading => ({
                x: reading.timestamp,
                y: reading.speed
            }));

            speedChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Raw Speed (Knots)',
                        data: data,
                        borderColor: '#3b82f6', // blue-500
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        tension: 0.1,
                        pointRadius: 1,
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'second',
                                displayFormats: {
                                    second: 'h:mm:ss a'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                color: '#9ca3af' // gray-400
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Speed (Knots)'
                            },
                            ticks: {
                                color: '#9ca3af'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (!speedChart) return;
            
            // Map the data from our buffer into the Chart.js structure
            const chartData = speedBuffer.map(reading => ({
                x: reading.timestamp,
                y: reading.speed
            }));

            speedChart.data.datasets[0].data = chartData;
            
            // Set the X-axis range to the last GRAPH_WINDOW_SEC seconds
            const now = Date.now();
            const timeCutoff = now - (GRAPH_WINDOW_SEC * 1000);
            speedChart.options.scales.x.min = timeCutoff;
            speedChart.options.scales.x.max = now;

            speedChart.update('none'); // 'none' skips animation for faster updates
        }


        // --- 5. GEOLOCATION HANDLERS (Time Filter Added) ---

        function handlePosition(position) {
            const currentCoords = position.coords;
            const timestamp = position.timestamp;
            
            // 1. CRITICAL FIX: Save the very first fix and exit.
            if (lastPosition === null) {
                lastPosition = position;
                showStatus("Waiting for a second GPS fix to calculate speed...", false);
                return; 
            }

            // 2. Speed Calculation
            const { speed_mps, time_sec } = calculateSpeed(position);
            const speedInKnots = mpsToKnots(speed_mps);
            
            // Find the last accepted speed for acceleration check
            const lastAcceptedSpeed = speedBuffer.length > 0 ? speedBuffer[speedBuffer.length - 1].speed : 0.0;
            
            // --- FILTER CHECKS ---

            // NEW 3. Time Delta Filter (must be done before other checks)
            if (time_sec < MIN_TIME_DELTA_SECONDS) {
                showStatus(`GPS fix received, but time delta (${time_sec.toFixed(1)}s) is too short. Waiting for ${MIN_TIME_DELTA_SECONDS}s...`, false);
                return; 
            }

            // 4. Velocity Filter (Max Speed Check)
            if (speedInKnots > MAX_SAILING_SPEED_KNOTS) {
                showStatus(`Speed of ${speedInKnots.toFixed(1)} knots rejected. Exceeds MAX_SAILING_SPEED (${MAX_SAILING_SPEED_KNOTS.toFixed(1)}).`, false);
                return; 
            }
            
            // 5. Acceleration Filter (Max Change Check)
            if (time_sec > 0) {
                const speedChange = Math.abs(speedInKnots - lastAcceptedSpeed);
                const acceleration = speedChange / time_sec;
                
                if (acceleration > MAX_ACCELERATION_KNOTS_PER_SEC) {
                    showStatus(`Speed change rejected. Acceleration too high (${acceleration.toFixed(2)} knots/sec).`, false);
                    return; 
                }
            }
            
            // 6. Data Saving and Display Update
            
            // Check against minimum speed threshold
            if (speedInKnots > MIN_SPEED_KNOTS) { 
                
                // DATA ACCEPTED!
                speedBuffer.push({
                    speed: speedInKnots,
                    timestamp: timestamp,
                    lat: currentCoords.latitude,
                    lon: currentCoords.longitude
                });

                lastPosition = position;
                saveData();
                showStatus(`Valid speed of ${speedInKnots.toFixed(1)} knots accepted. Fix interval: ${time_sec.toFixed(1)}s.`, false, true); // Green status bar for accepted
            } else {
                // DATA REJECTED by MIN_SPEED_KNOTS filter
                lastPosition = position; 
                
                showStatus(`Speed too low (${speedInKnots.toFixed(2)} knots). Likely stationary or GPS drift.`, false);
            }
            
            // 7. Display Update
            const avgSpeed30 = calculateRollingAverage(AVERAGE_WINDOW_30_SEC);
            const avgSpeed10 = calculateRollingAverage(AVERAGE_WINDOW_10_SEC);

            updateDisplay('avg-speed-30', avgSpeed30);
            updateDisplay('avg-speed-10', avgSpeed10);
            updateChart(); // CHART UPDATE IS HERE
        }

        function handleError(error) { /* ... (Unchanged) ... */ }

        // --- 6. INITIALIZATION (Unchanged) ---
        
        function startWatchAfterInitialFix(position) {
            handlePosition(position);

            watchId = navigator.geolocation.watchPosition(
                handlePosition,
                handleError,
                {
                    timeout: 5000,
                    maximumAge: 900000 
                }
            );
        }

        function startGpsWatch() {
            loadData();
            initChart(); 
            
            if (navigator.geolocation) {
                showStatus(speedBuffer.length > 0 ? "GPS Initializing. Displaying historical data..." : "Requesting initial GPS fix...", false);
                
                navigator.geolocation.getCurrentPosition(
                    startWatchAfterInitialFix,
                    handleError,
                    {
                        timeout: 10000, 
                        maximumAge: 900000 
                    }
                );
            } else {
                handleError({ code: -1, message: "Geolocation is not supported by this browser." });
            }
        }

        document.addEventListener('DOMContentLoaded', startGpsWatch);
        
        window.onbeforeunload = function() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
            }
        };
    </script>
</body>
</html>
